package org.jnetstream.packet;

import java.io.IOException;
import java.sql.Timestamp;
import java.util.Iterator;

import org.jnetstream.capture.CaptureDevice;
import org.jnetstream.protocol.Protocol;
import org.jnetstream.protocol.ProtocolEntry;
import org.jnetstream.protocol.ProtocolInfo;
import org.jnetstream.protocol.ProtocolRegistry;
import org.jnetstream.protocol.codec.CodecCreateException;

import com.slytechs.utils.memory.BitBuffer;
import com.slytechs.utils.net.Address;

/**
 * <p>
 * A packet that has been captured or read from a file and decoded. This is the
 * main interface for accessing packet information and content. The methods
 * {@link #getHeader} and {@link #getMetaPacket} provide access to decoded
 * contents of the packet. The decoding proccess is implementation dependent as
 * to exactly when it happens. The most efficient way is to decode only what is
 * needed to fulfill any given request. Packet content may or may not have been
 * decoded during packet aquisition (reading from file or live capture.) Some
 * packet contents may have been decoded due inorder to evaluate complex filter
 * expressions, or some other such reason. For the most part though the user can
 * assume that no or just minimal decoding of the packet contents has taken
 * place.
 * <p>
 * <p>
 * Packet decoding is done using the current codec registered for each protocol
 * in the protocol registry. Protocol decoding is done according to the
 * currently set protocol decoding defaults in the protocol registry. The
 * default is to do on-demand protocol decoding which triggers protocol header
 * decoding only when such a header is accessed such as a header
 * interation/traversal or direct call to getHeader.
 * </p>
 * <p>
 * The headers returned are backed by the packet buffer which contains all of
 * the packet's content. Any changes to the packet's buffer or through the
 * individual header interface must be followed by a call to {@link #update}
 * which will cause the previosly returned packet state to be discarded and
 * redecoded. Changes to the packet's or header's buffers can have global
 * consequences within a packet as protocol binding may have been altered or
 * other fields that have dependencies on them. Therefore after each call that
 * modifies the content of the packet buffer you should call update inorder to
 * sychronize the state of the packet structure with the packet buffer. Using
 * and invalidated header due to packet buffer changes may throw
 * IllegalStateException or override some other portion of the packet buffer
 * content.
 * </p>
 * <p>
 * All operations wheather immutable or mutable are done on the packet buffer.
 * There are numerous ways to modify this packet buffer either directly, through
 * the Packet or PcapBlockHeader API or indirectly outside the current API. All
 * changes should be synchronized after the updates are complete with an update
 * call which will redecode the packet buffer using all the know protocol and
 * NPL definitions.
 * </p>
 * <p>
 * Lastly, notice that you are able to modify the packet contents that came from
 * a read-only file. This means that although you can modify the packet content,
 * you are not able to flush the changes to a file and you will get an error.
 * </p>
 * 
 * @author Mark Bednarczyk
 * @author Sly Technologies, Inc.
 */
public interface Packet extends Iterable<Header> {

	/**
	 * Properties which are autogenerated or exported from NPL definition.
	 * 
	 * @author Mark Bednarczyk
	 * @author Sly Technologies, Inc.
	 */
	public enum Property {

		/**
		 * Special property that is used to initialize fields when packet is created
		 * from memory.
		 */
		Init(PacketInitializer.class),

		/**
		 * Included length property holds the number of bytes that were captured for
		 * the packet which may be less then the original size of the packet. Can be
		 * used in the Packet.getProperty call.
		 */
		Included(Integer.class),
		/**
		 * Original length property holds the original size of the packet when it
		 * was captured on the wire. The packet may have been truncated afterwards.
		 * Can be used in the Packet.getProperty call.
		 */
		Original(Integer.class),

		/**
		 * Timestamp seconds property as a unix timestamp. The capture timestamp
		 * contains number of a second since a common time of exactly when the
		 * packet was captured. The actual accuracy of the nanos timestamp component
		 * is hardware dependent. Can be used in the Packet.getProperty call.
		 */
		Seconds(Long.class),

		/**
		 * The capture timestamp contains a fraction of a second, specified in nano
		 * seconds of exactly when the packet was captured. The actual accuracy of
		 * the nanos timestamp component is hardware dependent. Even when the
		 * hardware is only capable of recording micro-second timestamp resolution,
		 * the micro second fraction is converted to nanos. Can be used in the
		 * Packet.getProperty call.
		 */
		Nanos(Long.class),

		/**
		 * A readonly Property which combines the Seconds and Nanos properties into
		 * a single object which can display the value nicely formatted. Type
		 * <code>Timestamp.class</code>.
		 */
		Timestamp(Timestamp.class),

		/**
		 * Source address of this packet as exported by the highest OSI level header
		 */
		SourceAddress(Address.class),

		/**
		 * Destination address of this packet as exported by the highest OSI level
		 * header
		 */
		DestinationAddress(Address.class),

		/**
		 * Source port number of this packet, if exists, of the highest level OSI
		 * level header
		 */
		SourcePort(Integer.class),

		/**
		 * Destination port number of this packet, if exists, of the highest level
		 * OSI level header
		 */
		DestinationPort(Integer.class),

		/**
		 * <p>
		 * Flow key associated with this packet.
		 * </p>
		 * TODO: Change the Object.class to FlowKey class when implemented
		 */
		FlowKey(Object.class),

		/**
		 * Raw index of this packet as it was captured, read or created
		 */
		Index(Long.class),
		LongSummary(String.class),
		ShortSummary(String.class), ;

		private final Class<?> cl;

		private Property(Class<?> c) {
			this.cl = c;
		}

		/**
		 * Returns the class that must be used to hold the value of this property
		 * 
		 * @return class object of the value type
		 */
		public Class<?> getValueType() {
			return cl;
		}
	}

	/**
	 * Formats content of this packet into human readable format using the default
	 * formatter and sends the output to the default output device.
	 * 
	 * @throws IOException
	 *           any IO errors while sending output
	 */
	public void format() throws IOException;

	/**
	 * Gets a buffer that contains the packet's data. The the position and limit
	 * of the buffer will be set to the start and length of the packet data,
	 * respectively. The capacity of the buffer may be more then the limit as the
	 * underlying storage or may be allocated larger then actual packet size to
	 * preempt possible expansion of the packet data. That is if the buffer the
	 * user can exapand the packet by adding fields to it and pushing the "limit"
	 * property of the buffer out to as much as buffer's capacity.
	 * 
	 * @return buffer containing this packet data
	 * @throws IOException
	 */
	public BitBuffer getBuffer() throws IOException;

	/**
	 * <p>
	 * Returns the undecoded portion of the packet. This is typically the data
	 * portion of the packet starting at the first octet past the end of the last
	 * header decoded in the packet. The buffer returned has its "position",
	 * "limit" and "capacity" properties initialized as follows, where position =
	 * the start of the undecoded buffer within the main packet buffer. Undecoded
	 * buffer position property is set to 0, the limit is set to
	 * <Code>Packet.getIncludedLength() -
	 * position</Code> which is the end of
	 * the packet data. Capacity is set to
	 * <Code>Packet.getBuffer().capacity() - position</Code> which corresponds
	 * to all the underlying packet buffer capacity allocated for this packet.
	 * Packets typically captured from a live network interface will not have any
	 * extra capacity but packets read from a file or initialized by a user may.
	 * </p>
	 * <p>
	 * <B>Note</B> that if you modify the contents of this buffer the underlying
	 * packet buffer will also be modified and visa versa. Also note that unlike
	 * modifying decoded headers it may or may not be neccessary to call update.
	 * In the case where you do not want the new packet protocol structure to be
	 * redecoded, you do not need to call the {@link #update} method. If you
	 * append a new header by adding the neccessary byte data into this buffer and
	 * you want the new protocol header to be discovered, then you need to call on
	 * update method. Afterwards, if all goes well you should be able to call
	 * Packet.getLastHeader(MyHeader.class) and get the newly added header. Lastly
	 * note that if you do change the structure of the packet and do call update
	 * method, you must also call the getUndecodedBuffer method again since the
	 * buffer will change due to the new header that was added.
	 * </p>
	 * 
	 * @return a new buffer which contains the undecoded (usually data) portion of
	 *         the packet
	 * @throws IOException
	 */
	public BitBuffer getData() throws IOException;

	/**
	 * <p>
	 * Returns the specified header from this packet. Before calling this method
	 * the {@link #hasHeader} or {@link #hasCompleteHeader} calls must be called
	 * atleast once for each header being requested. If the check is not made,
	 * even though the header exists in the packet, an IllegalStateException will
	 * be thrown. This is simlar to standard Iterator's hasNext requirement. The
	 * reason for this requirement is that it is the structure of a packet is so
	 * dynamic and changing from packet to packet, that this check has been made
	 * mandatory and a requirement to prevent unexpected errors. Also note that
	 * the same checks have to be done again after a call to {@link #update} on a
	 * packet. This is because the packet structure may have changed enough that
	 * all previously returned headers are no longer valid or exist in the packet.
	 * Only the first header of the specified type encountered is returned.
	 * </p>
	 * <p>
	 * Example:
	 * 
	 * <pre>
	 * for (Packet packet : Captures.openLive(10)) { // Capture 10 packets
	 * 	if (packet.hasHeader(Ethernet.class)) {
	 * 		Ethernet ethernet = packet.getHeader(Ethernet.class);
	 * 		EUI48 destination = ethernet.destination();
	 * 		EUI48 source = ethernet.source();
	 * 		short type = ethernet.type();
	 * 	}
	 * 
	 * 	if (packet.hasCompleteHeader(Ip.class)) {
	 * 		Ip ip = packet.getHeader(Ip.class);
	 * 		// And so forth
	 * 	}
	 * }
	 * Captures.close(); // Closes last open capture
	 * </pre>
	 * 
	 * </p>
	 * 
	 * @see #getHeader(Protocol)
	 * @see #hasHeader(Class)
	 * @param <T>
	 *          protocol class type
	 * @param c
	 *          protocol's static class file
	 * @return header of the class type and this method never returns null
	 * @throws IllegalStateException
	 *           thrown if header was not found
	 * @throws IOException
	 */
	public <T extends Header> T getHeader(Class<T> c)
	    throws IllegalStateException, IOException;

	/**
	 * <p>
	 * Same as the alternative version of {@link #getHeader(Class)} method, but
	 * faster. You can speed up retrieval of headers if you do the lookup of the
	 * protocol yourself. The use of parameterized header retrieval ensures
	 * compile time type safety of the retrieved header.
	 * </p>
	 * <p>
	 * Here is an example:
	 * 
	 * <pre>
	 * final Protocol&lt;Ethernet&gt; ETHERNET = ProtocolRegistry.getProtocol(Ethernet.class);
	 * final Protocol&lt;Ip&gt; IP = ProtocolRegistry.getProtocol(Ip.class);
	 * 
	 * for (Packet packet: Capture.openLive(10)) {
	 * 	if (packet.hasHeader(ETHERNET) {
	 * 		Ethernet ethernet = packet.getHeader(ETHERNET);
	 * 		// And so forth
	 * 	}
	 * }
	 * Captures.close(); // Closes last open capture
	 * </pre>
	 * 
	 * </p>
	 * 
	 * @see #getHeader(Class)
	 * @see #hasHeader(ProtocolEntry)
	 * @see ProtocolRegistry#getProtocol(Class)
	 * @param <T>
	 *          protocol class type
	 * @param p
	 *          instance of a protocol as retrieved from protocol registry
	 * @return header of the class type and this method never returns null
	 * @throws IllegalStateException
	 *           thrown if header was not found
	 * @throws IOException 
	 */
	public <T extends Header> T getHeader(Protocol p)
	    throws IllegalStateException, IOException;

	/**
	 * Returns the number of decoded headers within this packet. This method call
	 * may encure performance penalty as usually the only way to count how may
	 * headers are within packet is to actually iterate and decode parts of each
	 * header to the end. This may not neccessarily mean that the headers are
	 * decoded completely, but only that portions of the headers is decoded so
	 * that the header type of the header following the one being decoded can be
	 * assertained.
	 * 
	 * @return number of currently decoded or decodable headers within the packet
	 * @throws IOException 
	 */
	public int getHeaderCount() throws IOException;

	/**
	 * Gets the length of the packet content from the current buffer. The length
	 * is the current length of the available data, which may differ from the
	 * original length of the packet if the packet has been trucated. This
	 * property can also be accessed using the property object accessor
	 * getProperty.
	 * 
	 * @return length in octets of the full packet size that is contain
	 * @throws IOException
	 */
	public long getIncludedLength() throws IOException;

	/**
	 * Gets the length of the packet as it was seen on the wire while originally
	 * captured. The original length may differ from included length if the
	 * captured packet was trucated after the capture and only portion of the
	 * packet had been included.
	 * 
	 * @return length in octets of the full packet size of the original packet as
	 *         seen on the network wire
	 */
	public long getOriginalLength() throws IOException;

	/**
	 * Gets the timestamp as recorded at the time of the packet capture in
	 * fraction of a second, in nanoseconds. The valid range is from 0 to
	 * 999,999,999 nanoseconds. The value is always returned in nanoseconds even
	 * when the capturing device, such as a network interface, is not capable of
	 * timestamping at nanosecond resolution. In case the capture device has
	 * microsecond resolution, the valid value of this counter would be from 0 to
	 * 999,999,000. To determine the timestamp real resolution of the capturing
	 * device use the method {@link #getCaptureDevice()} and then
	 * {@link CaptureDevice#getTimestampResolution} which will return an enum
	 * constant which describes if the resulution is in nanoseconds or
	 * microseconds. In either case this information should only be required in
	 * rare circuimstances as the timestamp is always converted and reported in
	 * nanoseconds, no matter what the resolution actually is.
	 * 
	 * @return fraction of a second in nanosecond increments in valid range of 0
	 *         to 999,999,999
	 */
	public long getTimestampNanos() throws IOException;

	/**
	 * Gets the timestamp as recorded at the time of the packet capture in number
	 * of seconds since 1.1.1970.
	 * 
	 * @return number of seconds
	 */
	public long getTimestampSeconds() throws IOException;

	/**
	 * <p>
	 * Checks if a complete, untruncated, header exists in this packet. If the
	 * header exists, but is incomplete due to snaplen, this method will return
	 * false. Only the first header of the specified type encountered is returned.
	 * </p>
	 * <p>
	 * <b>Implementation Note:</b> the check performed is very efficient and does
	 * not neccessarily mean that any back-end objects needed to be instantiated.
	 * The presence of a header is encoded using bit fields, and checked very
	 * efficiently. This method does require a scan of the packet the first time
	 * its called, inorder to determine which headers are present, but that is
	 * also done very efficiently using low level scanner. Once the single scan of
	 * a packet has been performed any subsequent header checks are typically a
	 * single bitwise operation.
	 * </p>
	 * 
	 * @param <T>
	 *          Stubfile's header class for the requested header.
	 * @param c
	 *          Class of the header to check for. Java classes for all headers are
	 *          generated as java stubfiles during NPL definition compile.
	 * @return true if header exists and has not been truncated, false if it
	 *         exists and has been truncated and also false if it doesn't exist.
	 * @throws IOException
	 * @throws CodecCreateException
	 */
	public <T extends Header> boolean hasCompleteHeader(Class<T> c)
	    throws CodecCreateException, IOException;

	public <T extends Header> boolean hasCompleteHeader(ProtocolInfo<T> p)
	    throws CodecCreateException, IOException;

	/**
	 * <p>
	 * Checks for presence of the specified header within this particular packet.
	 * The header may be either complete or truncated due to snaplen, but it does
	 * exist in this header. Only the first header of the specified type
	 * encountered is returned.
	 * </p>
	 * <p>
	 * <b>Implementation Note:</b> the check performed is very efficient and does
	 * not neccessarily mean that any back-end objects needed to be instantiated.
	 * The presence of a header is encoded using bit fields, and checked very
	 * efficiently. This method does require a scan of the packet the first time
	 * its called, inorder to determine which headers are present, but that is
	 * also done very efficiently using low level scanner. Once the single scan of
	 * a packet has been performed any subsequent header checks are typically a
	 * single bitwise operation.
	 * </p>
	 * 
	 * @param <T>
	 *          Stubfile's header class for the requested header.
	 * @param c
	 *          Class of the header to check for. Java classes for all headers are
	 *          generated as java stubfiles during NPL definition compile.
	 * @return true if header exists
	 * @throws IOException
	 * @throws CodecCreateException
	 */
	public <T extends Header> boolean hasHeader(Class<T> c)
	    throws CodecCreateException, IOException;

	public <T extends Header> boolean hasHeader(ProtocolEntry p)
	    throws CodecCreateException, IOException;

	/**
	 * <p>
	 * Causes all or parts of the previous state of the packet to be discarded and
	 * recomputed. Any previoulsy returned headers have to be reaquired using the
	 * {@link #hasHeader}, {@link #hasCompleteHeader} and {@link #getHeader}
	 * calls.
	 * </p>
	 * <p>
	 * You use the update method when any of the packet buffer data has been
	 * changed by either direct manipulation on the packet buffer as returned by
	 * {@link #getBuffer}, {@link PcapBlockHeader#GetBuffer} or by calls to any
	 * of the setter header methods for each protocol such as in the example
	 * below:
	 * 
	 * <pre>
	 * 
	 * if (packet.hasCompleteHeader(IPv4.class) == false) {
	 * 	return;
	 * }
	 * 
	 * IPv4 ip = packet.getHeader(IPv4.class);
	 * ip.version(6); // Call the setter method
	 * packet.update(); // We return here since we changed our IPv4 header to IPv6 
	 * 
	 * if (packet.hasCompleteHeader(IPv4.class) == false) {
	 * 	return;
	 * }
	 * 
	 * </pre>
	 * 
	 * The above example changes the IP version field from IP version 4 to 6 in
	 * the packet's buffer which means that the original IPv4 header is no longer
	 * valid as the packet buffer content no longer contain an IPv4 header. After
	 * the call to <code>packet.update()</Code>, you must again use the
	 * hasCompleteHeader and getHeader method calls to reaquire the header.
	 * </p>
	 * <p>
	 * If the changes to the packet's buffer do not actually change the structure
	 * of the packet but only change the value of a less significant field, the
	 * Codec implementation will reuse existing header and return the same
	 * reference with the updated field value. Here is another example:
	 * 
	 * <pre>
	 * if (packet.hasCompleteHeader(IPv4.class) == false) {
	 * 	return;
	 * }
	 * 
	 * IPv4 ip = packet.getHeader(IPv4.class);
	 * ip.sourceAddress(new IpAddress(&quot;192.168.1.2&quot;));
	 * packet.update();
	 * 
	 * // Will not return here, since the original IPv4 header is still valid
	 * if (packet.hasCompleteHeader(IPv4.class) == false) {
	 * 	return;
	 * }
	 * 
	 * ip = packet.getHeader(IPv4.class); // We will aquire the same reference as previous IPv4
	 * Syste.out.println(&quot;Source address=&quot; + ip.sourceAddress());
	 * </pre>
	 * 
	 * Since the packet structure was not changed only a less significant value of
	 * a field which did not have any impact on the packet structure, the original
	 * IPv4 is kept in tact. Note that you were still required to make the call to
	 * hasCompleteHeader and then to getHeader, but the getHeader may actually
	 * have returned the exact same reference as it it to the first getHeader
	 * call, but this is not guarrantee and the second call to getHeader must be
	 * made. It is not safe to assume that the original reference returned by the
	 * first call to getHeader is still valid although it might. Also note that if
	 * you had called on the getHeader without first cheking hasCompleteHeader or
	 * hasHeader, the second getHeader call would have thrown
	 * IllegalStateException. It is best to assume that after a call to
	 * {@link #update} you are working again with a brand new packet which may
	 * have completely different structure. The implementation will choose the
	 * most efficient way to incorporate the changes, rebuild the state of the
	 * packet structure, reuse or not touch previously decoded headers. The
	 * implementation will return previously decoded objects as efficiently as
	 * possible. So for a simple change like in the example above where no
	 * structural changes took place, the update call is extremely fast and
	 * reaquiring of all the references is very efficient and only imposes a very
	 * slight overhead to the overall code.
	 * </p>
	 * 
	 * @throws IOException
	 * @throws CodecException
	 */
	// TODO: remove - public void update() throws CodecException, IOException;
	/**
	 * Checks if the packet has been truncated from the original length as seen on
	 * the network wire. If snaplen has been set during the packet capture, the
	 * data captured is only partial data of the original.
	 * 
	 * @return true that packet has been truncated, otherwise false
	 * @throws IOException
	 */
	public boolean isTruncated() throws IOException;

	/**
	 * Allows all the headers to be iterated through using the foreach() syntax.
	 * 
	 * @return iterator that can be used in a foreach() statement. Iterator will
	 *         iterate through all the headers
	 */
	public Iterator<Header> iterator();

	/**
   * @param property
   * @return
   */
  public <A> A getProperty(Property property);

	/**
   * @return
	 * @throws IOException 
   */
  public Header[] getAllHeaders() throws IOException;
}
