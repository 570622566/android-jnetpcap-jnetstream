/**
 * Copyright (C) 2007 Sly Technologies, Inc. This library is free software; you
 * can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version. This
 * library is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details. You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
package org.jnetstream.filter.bpf;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.LinkedList;
import java.util.List;

/**
 * A set of instructions compiled from a textual expression to a binary level
 * which can be passed to a BPF VM for interpretation.
 * 
 * @author Mark Bednarczyk
 * @author Sly Technologies, Inc.
 */
public class BPFProgram {

	/**
	 * Converts a rawBuffer byte[] byte code into an array of more java friendly
	 * BPFInstructions. The instructions are assumed to be in big-endian (most
	 * significant) byte order.
	 * 
	 * @param program
	 *          the rawBuffer byte code program to convert
	 * @return converted program to an instruction array
	 * @throws IllegalInstructionException
	 *           if an unrecognized instruction is encountered
	 */
	public static BPFInstruction[] convertBE(final byte[] program)
	    throws IllegalInstructionException {
		final List<BPFInstruction> list = new LinkedList<BPFInstruction>();

		for (int i = 0; i < program.length; i += 8) {
			list.add(new BPFInstruction(program, i, ByteOrder.BIG_ENDIAN));
		}

		final BPFInstruction[] inst = new BPFInstruction[list.size()];

		return list.toArray(inst);
	}

	/**
	 * Converts a rawBuffer byte[] code into an array of more java friendly
	 * BPFInstructions. The instructions are assumed to be in little-endian (least
	 * significant) byte order.
	 * 
	 * @param program
	 *          the rawBuffer byte code program to convert
	 * @return converted program to an instruction array
	 * @throws IllegalInstructionException
	 *           if an unrecognized instruction is encountered
	 */
	public static BPFInstruction[] convertLE(final byte[] program)
	    throws IllegalInstructionException {
		final List<BPFInstruction> list = new LinkedList<BPFInstruction>();

		for (int i = 0; i < program.length; i += 8) {
			list.add(new BPFInstruction(program, i, ByteOrder.LITTLE_ENDIAN));
		}

		final BPFInstruction[] inst = new BPFInstruction[list.size()];

		return list.toArray(inst);
	}

	private BPFInstruction[] code;

	private ByteOrder encoding;

	private int length;

	private ByteBuffer rawBuffer;
	
	public BPFProgram(final BPFInstruction[] code, final ByteOrder order) {
		this.code = code;
		this.encoding = order;
	}

	/**
	 * Compiles the supplied rawBuffer BPF byte code array into a more java
	 * friendly BPFInstruction program.
	 * 
	 * @throws IllegalInstructionException
	 *           if an unrecognized instruction is encountered in the pc array
	 */
	public BPFProgram(final byte[] pc) throws IllegalInstructionException {
		this.rawBuffer = ByteBuffer.wrap(pc);
		this.length = pc.length / 8; // Number of instructions
		IllegalInstructionException notBig;
		IllegalInstructionException notLittle;

		try {
			this.code = BPFProgram.convertBE(pc);
			this.encoding = ByteOrder.BIG_ENDIAN;

			return;
		} catch (final IllegalInstructionException e) {
			notBig = e;
		}

		try {
			this.code = BPFProgram.convertLE(pc);
			this.encoding = ByteOrder.LITTLE_ENDIAN;
			return;
		} catch (final IllegalInstructionException e) {
			notLittle = e;
		}

		throw new IllegalInstructionException(
		    "Couldn't match instruction in big and little endian encodings: \n["
		        + notBig.getMessage() + "],\n[" + notLittle.getMessage() + "]");
	}

	/**
	 * Initializes this BPF program from a tcpdump/libpcap generated pseudo code.
	 * The pseudo code is compiled to binary form and initialized.
	 * 
	 * @param tcpdumpText
	 *          the pseudo code as generated by tcpdump/libpcap tools
	 * @throws IllegalInstructionException
	 *           if an unrecognized instruction is encountered
	 */
	public BPFProgram(final String tcpdumpText) throws IllegalInstructionException {

		this.code = PcapDebugFilter.compileTcpdumpOutput(tcpdumpText);
		this.length = this.code.length;
	}

	/**
	 * Gets the java friendly compiled BPF instruction code.
	 * 
	 * @return Returns the code.
	 */
	public final BPFInstruction[] getCode() {
		return this.code;
	}

	/**
	 * Gets the byte encoding of this program.
	 * 
	 * @return Returns the encoding.
	 */
	public final ByteOrder getEncoding() {
		return this.encoding;
	}

	/**
	 * @return Returns the length.
	 */
	public final int getLength() {
		return this.length;
	}

	/**
	 * Gets the raw byte code of this bpf program.
	 * 
	 * @return Returns the rawBuffer that contains the raw BPF byte code.
	 */
	public final ByteBuffer getRawBuffer() {
		if (this.rawBuffer == null) {

			final byte[] b = new byte[this.code.length];
			this.rawBuffer = ByteBuffer.wrap(b);

			for (final BPFInstruction inst : this.code) {
				this.rawBuffer.put(inst.encodeToBinary());
			}
		}

		return this.rawBuffer;
	}

	/**
	 * @param buf
	 * @return
	 */
	public StringBuilder toBuffer(final StringBuilder buf) {
		buf.append(this.toString());
		return buf;
	}

	public StringBuilder toBufferCode(final StringBuilder buf) {
		int counter = 0;
		for (final BPFInstruction i : this.code) {
			buf.append("#").append(counter++).append(" ").append(i.toString())
			    .append("\n");
		}
		return buf;
	}

	@Override
	public String toString() {
		final String s = "[Len=" + this.code.length + ", encoding=" + this.encoding
		    + "]";

		return s;
	}

	/**
	 * @return
	 */
	public String toStringCode() {
		final StringBuilder buf = new StringBuilder(2024);

		return this.toBufferCode(buf).toString();
	}

}
