/**
 * Copyright (C) 2007 Sly Technologies, Inc. This library is free software; you
 * can redistribute it and/or modify it under the terms of the GNU Lesser
 * General Public License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version. This
 * library is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details. You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */
package org.jnetstream.filter.bpf;

import java.nio.ByteOrder;

import org.jnetstream.filter.FilterNotFoundException;
import org.jnetstream.filter.FilterSyntaxError;
import org.jnetstream.filter.FilterTarget;


/**
 * @author Mark Bednarczyk
 * @author Sly Technologies, Inc.
 */
public class PcapDebugFilter extends PcapFilter {

	public static final String TYPE = "TcpdumpPseudo";

	/**
	 * Compiles a tcpdump/libpcap generated pseudo BPF code to binary form
	 * suitable for use with BPFProgram.
	 * 
	 * @param text
	 *          the textual pseudo code as generated by tcpdump/libpcap tools
	 * @return array of compiled BPFInstructions that are more java friendly
	 * @throws IllegalInstructionException
	 *           if an unrecognized instruction is encountered
	 */
	public static BPFInstruction[] compileTcpdumpOutput(final String text)
	    throws IllegalInstructionException {

		final String[] c = text.trim().split("\n");
		BPFInstruction[] pc = new BPFInstruction[c.length];

		int i = -1;
		for (String l : c) {

			l = l.trim().replaceAll("\\{\\s", "").replaceAll(" \\},", "").replaceAll(
			    ",\\s", ",").replaceAll("0x", "");
			if ("".equals(l)) {
				continue;
			}
			i++;

			// System.out.println("l=[" + l + "]");

			final String[] o = l.split(",");
			final int code = Integer.parseInt(o[0], 16);
			final int jt = Integer.parseInt(o[1]);
			final int jf = Integer.parseInt(o[2]);
			final long k = Long.parseLong(o[3], 16);

			pc[i] = new BPFInstruction(code, jt, jf, k);

		}

		/*
		 * Check is we skipped any lines in the middle and the array is actually too
		 * big. If it is, copy into the proper size array
		 */
		if (i != pc.length) {
			final BPFInstruction[] na = new BPFInstruction[i + 1];

			while (i >= 0) {
				na[i] = pc[i];
				i--;
			}

			pc = na;
		}

		return pc;
	}

	private BPFProgram program;

	private final FilterTarget target;

	public PcapDebugFilter(String tcpdumpOutput, FilterTarget target)
	    throws IllegalInstructionException {
		super(tcpdumpOutput);
		
		this.target = target;
		this.program = new BPFProgram(compileTcpdumpOutput(tcpdumpOutput),
		    ByteOrder.nativeOrder());
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.jnetstream.filter.FilterExpression#compile(org.jnetstream.filter.FilterTarget)
	 */
	public BPFProgram compile(FilterTarget target) throws FilterSyntaxError,
	    FilterNotFoundException {

		if (this.target != target) {
			throw new FilterNotFoundException(
			    "Unable to compile expression to filter target [" + target + "]");
		}

		return program;
	}
}
